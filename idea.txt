很显然，叫什么名字并不重要
但新的语言该开始写了
仍然沿用去年的标记清除GC（因为简单）
主要用于TermEd和随后用C语言写的编辑器的配置和插件
可以借鉴一点Lua的元表的思路
应该像Lua一样提供简洁的调用和扩展接口
这次不再使用全局GC
很显然没有必要使用复杂的分步式GC
直接把vals和gc放一块吧，反正不多（bushi

2025-10-9写
为了区分obj.fn(xxx)时究竟是否以obj为第一个参数，要区分method和func类型

2025-10-10写
还是C语言好啊，vm用gc思维写，解析用所有权思维写，互不干扰
在tokenlist中将strs单独存储，解析完成后可以free掉tokenlist::v和整棵语法树但保留strs提供给vm
输出和判等的循环引用还挺难搞的，得有点数学功底，干脆交给用户

2025-10-11写
终于把gc和table的测试过了
后面就一马平川了，基本没有什么复杂的，试错早在一年前就完成了

2025-10-13写
类型系统的一些细节还没确定、、、
我认为可以完全复制Lua的经验，不用类，object+metatable即可
但问题是这样写着不好看（
再或者提供type语句作为语法糖，但感觉这样很奇怪

2025-10-14写
可以给GC类型全部提供metatable的覆写能力，反正不差那点空间

2025-10-15写
不行，这样太麻烦，而且不太舒服，因此仍然只允许object具有metatable
不得不区分type和object，否则method call会有歧义
我显然不想像Lua那样区分.和:，看着就难受

2025-10-17写
最大的问题在于回收时析构函数的处理
不能不提供析构函数，否则扩展类型会无法管理
但如果提供就要将vm和val关联，难度巨大
好吧，我选择使gc_collect返回一个含有所有要回收对象的链表

2025-10-18写
类型系统还是有比较好的扩展性的，至少基础类型可以无开销随意添加
突然发现object+metatable就是scope了啊，编译方面直接不用实现scope了
这个语言对可扩展性的要求比之前要高得多，最好能像Lua一样支持动态地向全局作用域中加入变量
然而这显然很难做到，bl系的逻辑是在编译阶段确定变量位置
也许可以两样并行，全局提供一个扩展表，加入LOADEXT和SETEXT字节码
不对，不应该提供SETEXT，否则就要变成Lua了（没有local一律是全局变量）（
虽然但是，是可以在extglobal中提供用于定义全局变量的函数的、、、

2025-10-22写
早期实现先不管析构函数了，这个有点复杂，也许11.6之后再说

2025-10-24写
该开始写编译了

2025-10-25写
构造函数也先不搞了，有点复杂，先写出原型再说
可恶，设计metatable的时候忘了多继承这茬了、、、
不过可以搞一个combinedobj，甚至效率不低

2025-10-26写
完了完不成了，直接把类系列的全部扔掉

2025-11-8写
差不多完成了，可以写基础类型的元表了
